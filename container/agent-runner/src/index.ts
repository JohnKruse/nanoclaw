/**
 * NanoClaw Agent Runner
 * Runs inside a container, receives config via stdin, outputs result to stdout
 *
 * Input protocol:
 *   Stdin: Full ContainerInput JSON (read until EOF, like before)
 *   IPC:   Follow-up messages written as JSON files to /workspace/ipc/input/
 *          Files: {type:"message", text:"..."}.json — polled and consumed
 *          Sentinel: /workspace/ipc/input/_close — signals session end
 *
 * Stdout protocol:
 *   Each result is wrapped in OUTPUT_START_MARKER / OUTPUT_END_MARKER pairs.
 *   Multiple results may be emitted (one per agent teams result).
 *   Final marker after loop ends signals completion.
 */

import fs from 'fs';
import path from 'path';
import { query, HookCallback, PreCompactHookInput, PreToolUseHookInput } from '@anthropic-ai/claude-agent-sdk';
import { fileURLToPath } from 'url';

interface ContainerInput {
  prompt: string;
  sessionId?: string;
  groupFolder: string;
  chatJid: string;
  isMain: boolean;
  isScheduledTask?: boolean;
  secrets?: Record<string, string>;
}

interface ContainerOutput {
  status: 'success' | 'error';
  result: string | null;
  newSessionId?: string;
  error?: string;
}

interface SessionEntry {
  sessionId: string;
  fullPath: string;
  summary: string;
  firstPrompt: string;
}

interface SessionsIndex {
  entries: SessionEntry[];
}

interface SDKUserMessage {
  type: 'user';
  message: { role: 'user'; content: string };
  parent_tool_use_id: null;
  session_id: string;
}

interface OpenRouterMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface OpenRouterConfig {
  apiKey: string;
  model: string;
  baseUrl: string;
  httpReferer?: string;
  title?: string;
}

interface GmailOAuthCredentials {
  refresh_token?: string;
  client_id?: string;
  client_secret?: string;
  token_uri?: string;
}

interface ParsedSendEmailIntent {
  to: string;
  subject: string;
  body: string;
}

interface ParsedCalendarCreateIntent {
  summary: string;
  startIso: string;
  endIso: string;
  timezone: string;
}

const IPC_INPUT_DIR = '/workspace/ipc/input';
const IPC_INPUT_CLOSE_SENTINEL = path.join(IPC_INPUT_DIR, '_close');
const IPC_POLL_MS = 500;

function readMemoryMarkdown(dirPath: string): string | undefined {
  const preferred = path.join(dirPath, 'MEMORY.md');
  const legacy = path.join(dirPath, 'CLAUDE.md');
  if (fs.existsSync(preferred)) {
    return fs.readFileSync(preferred, 'utf-8');
  }
  if (fs.existsSync(legacy)) {
    return fs.readFileSync(legacy, 'utf-8');
  }
  return undefined;
}

/**
 * Push-based async iterable for streaming user messages to the SDK.
 * Keeps the iterable alive until end() is called, preventing isSingleUserTurn.
 */
class MessageStream {
  private queue: SDKUserMessage[] = [];
  private waiting: (() => void) | null = null;
  private done = false;

  push(text: string): void {
    this.queue.push({
      type: 'user',
      message: { role: 'user', content: text },
      parent_tool_use_id: null,
      session_id: '',
    });
    this.waiting?.();
  }

  end(): void {
    this.done = true;
    this.waiting?.();
  }

  async *[Symbol.asyncIterator](): AsyncGenerator<SDKUserMessage> {
    while (true) {
      while (this.queue.length > 0) {
        yield this.queue.shift()!;
      }
      if (this.done) return;
      await new Promise<void>(r => { this.waiting = r; });
      this.waiting = null;
    }
  }
}

async function readStdin(): Promise<string> {
  return new Promise((resolve, reject) => {
    let data = '';
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', chunk => { data += chunk; });
    process.stdin.on('end', () => resolve(data));
    process.stdin.on('error', reject);
  });
}

const OUTPUT_START_MARKER = '---NANOCLAW_OUTPUT_START---';
const OUTPUT_END_MARKER = '---NANOCLAW_OUTPUT_END---';

function writeOutput(output: ContainerOutput): void {
  console.log(OUTPUT_START_MARKER);
  console.log(JSON.stringify(output));
  console.log(OUTPUT_END_MARKER);
}

function log(message: string): void {
  console.error(`[agent-runner] ${message}`);
}

function getSessionSummary(sessionId: string, transcriptPath: string): string | null {
  const projectDir = path.dirname(transcriptPath);
  const indexPath = path.join(projectDir, 'sessions-index.json');

  if (!fs.existsSync(indexPath)) {
    log(`Sessions index not found at ${indexPath}`);
    return null;
  }

  try {
    const index: SessionsIndex = JSON.parse(fs.readFileSync(indexPath, 'utf-8'));
    const entry = index.entries.find(e => e.sessionId === sessionId);
    if (entry?.summary) {
      return entry.summary;
    }
  } catch (err) {
    log(`Failed to read sessions index: ${err instanceof Error ? err.message : String(err)}`);
  }

  return null;
}

/**
 * Archive the full transcript to conversations/ before compaction.
 */
function createPreCompactHook(): HookCallback {
  return async (input, _toolUseId, _context) => {
    const preCompact = input as PreCompactHookInput;
    const transcriptPath = preCompact.transcript_path;
    const sessionId = preCompact.session_id;

    if (!transcriptPath || !fs.existsSync(transcriptPath)) {
      log('No transcript found for archiving');
      return {};
    }

    try {
      const content = fs.readFileSync(transcriptPath, 'utf-8');
      const messages = parseTranscript(content);

      if (messages.length === 0) {
        log('No messages to archive');
        return {};
      }

      const summary = getSessionSummary(sessionId, transcriptPath);
      const name = summary ? sanitizeFilename(summary) : generateFallbackName();

      const conversationsDir = '/workspace/group/conversations';
      fs.mkdirSync(conversationsDir, { recursive: true });

      const date = new Date().toISOString().split('T')[0];
      const filename = `${date}-${name}.md`;
      const filePath = path.join(conversationsDir, filename);

      const markdown = formatTranscriptMarkdown(messages, summary);
      fs.writeFileSync(filePath, markdown);

      log(`Archived conversation to ${filePath}`);
    } catch (err) {
      log(`Failed to archive transcript: ${err instanceof Error ? err.message : String(err)}`);
    }

    return {};
  };
}

// Secrets to strip from Bash tool subprocess environments.
// These are needed by claude-code for API auth but should never
// be visible to commands Kit runs.
const SECRET_ENV_VARS = [
  'ANTHROPIC_API_KEY',
  'CLAUDE_CODE_OAUTH_TOKEN',
  'OPENROUTER_API_KEY',
];

function createSanitizeBashHook(): HookCallback {
  return async (input, _toolUseId, _context) => {
    const preInput = input as PreToolUseHookInput;
    const command = (preInput.tool_input as { command?: string })?.command;
    if (!command) return {};

    const unsetPrefix = `unset ${SECRET_ENV_VARS.join(' ')} 2>/dev/null; `;
    return {
      hookSpecificOutput: {
        hookEventName: 'PreToolUse',
        updatedInput: {
          ...(preInput.tool_input as Record<string, unknown>),
          command: unsetPrefix + command,
        },
      },
    };
  };
}

function sanitizeFilename(summary: string): string {
  return summary
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 50);
}

function generateFallbackName(): string {
  const time = new Date();
  return `conversation-${time.getHours().toString().padStart(2, '0')}${time.getMinutes().toString().padStart(2, '0')}`;
}

interface ParsedMessage {
  role: 'user' | 'assistant';
  content: string;
}

function parseTranscript(content: string): ParsedMessage[] {
  const messages: ParsedMessage[] = [];

  for (const line of content.split('\n')) {
    if (!line.trim()) continue;
    try {
      const entry = JSON.parse(line);
      if (entry.type === 'user' && entry.message?.content) {
        const text = typeof entry.message.content === 'string'
          ? entry.message.content
          : entry.message.content.map((c: { text?: string }) => c.text || '').join('');
        if (text) messages.push({ role: 'user', content: text });
      } else if (entry.type === 'assistant' && entry.message?.content) {
        const textParts = entry.message.content
          .filter((c: { type: string }) => c.type === 'text')
          .map((c: { text: string }) => c.text);
        const text = textParts.join('');
        if (text) messages.push({ role: 'assistant', content: text });
      }
    } catch {
    }
  }

  return messages;
}

function formatTranscriptMarkdown(messages: ParsedMessage[], title?: string | null): string {
  const now = new Date();
  const formatDateTime = (d: Date) => d.toLocaleString('en-US', {
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    hour12: true
  });

  const lines: string[] = [];
  lines.push(`# ${title || 'Conversation'}`);
  lines.push('');
  lines.push(`Archived: ${formatDateTime(now)}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  for (const msg of messages) {
    const sender = msg.role === 'user' ? 'User' : 'Andy';
    const content = msg.content.length > 2000
      ? msg.content.slice(0, 2000) + '...'
      : msg.content;
    lines.push(`**${sender}**: ${content}`);
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Check for _close sentinel.
 */
function shouldClose(): boolean {
  if (fs.existsSync(IPC_INPUT_CLOSE_SENTINEL)) {
    try { fs.unlinkSync(IPC_INPUT_CLOSE_SENTINEL); } catch { /* ignore */ }
    return true;
  }
  return false;
}

/**
 * Drain all pending IPC input messages.
 * Returns messages found, or empty array.
 */
function drainIpcInput(): string[] {
  try {
    fs.mkdirSync(IPC_INPUT_DIR, { recursive: true });
    const files = fs.readdirSync(IPC_INPUT_DIR)
      .filter(f => f.endsWith('.json'))
      .sort();

    const messages: string[] = [];
    for (const file of files) {
      const filePath = path.join(IPC_INPUT_DIR, file);
      try {
        const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
        fs.unlinkSync(filePath);
        if (data.type === 'message' && data.text) {
          messages.push(data.text);
        }
      } catch (err) {
        log(`Failed to process input file ${file}: ${err instanceof Error ? err.message : String(err)}`);
        try { fs.unlinkSync(filePath); } catch { /* ignore */ }
      }
    }
    return messages;
  } catch (err) {
    log(`IPC drain error: ${err instanceof Error ? err.message : String(err)}`);
    return [];
  }
}

/**
 * Wait for a new IPC message or _close sentinel.
 * Returns the messages as a single string, or null if _close.
 */
function waitForIpcMessage(): Promise<string | null> {
  return new Promise((resolve) => {
    const poll = () => {
      if (shouldClose()) {
        resolve(null);
        return;
      }
      const messages = drainIpcInput();
      if (messages.length > 0) {
        resolve(messages.join('\n'));
        return;
      }
      setTimeout(poll, IPC_POLL_MS);
    };
    poll();
  });
}

/**
 * Run a single query and stream results via writeOutput.
 * Uses MessageStream (AsyncIterable) to keep isSingleUserTurn=false,
 * allowing agent teams subagents to run to completion.
 * Also pipes IPC messages into the stream during the query.
 */
async function runQuery(
  prompt: string,
  sessionId: string | undefined,
  mcpServerPath: string,
  containerInput: ContainerInput,
  sdkEnv: Record<string, string | undefined>,
  resumeAt?: string,
): Promise<{ newSessionId?: string; lastAssistantUuid?: string; closedDuringQuery: boolean }> {
  const stream = new MessageStream();
  stream.push(prompt);

  // Poll IPC for follow-up messages and _close sentinel during the query
  let ipcPolling = true;
  let closedDuringQuery = false;
  const pollIpcDuringQuery = () => {
    if (!ipcPolling) return;
    if (shouldClose()) {
      log('Close sentinel detected during query, ending stream');
      closedDuringQuery = true;
      stream.end();
      ipcPolling = false;
      return;
    }
    const messages = drainIpcInput();
    for (const text of messages) {
      log(`Piping IPC message into active query (${text.length} chars)`);
      stream.push(text);
    }
    setTimeout(pollIpcDuringQuery, IPC_POLL_MS);
  };
  setTimeout(pollIpcDuringQuery, IPC_POLL_MS);

  let newSessionId: string | undefined;
  let lastAssistantUuid: string | undefined;
  let messageCount = 0;
  let resultCount = 0;

  // Provider-neutral memory loading: prefer MEMORY.md, fallback to CLAUDE.md
  const memoryParts: string[] = [];
  const groupMemory = readMemoryMarkdown('/workspace/group');
  if (groupMemory?.trim()) memoryParts.push(groupMemory);
  if (!containerInput.isMain) {
    const globalMemory = readMemoryMarkdown('/workspace/global');
    if (globalMemory?.trim()) memoryParts.push(globalMemory);
  }
  const mergedMemory = memoryParts.length > 0 ? memoryParts.join('\n\n') : undefined;

  // Discover additional directories mounted at /workspace/extra/*
  // These are passed to the SDK so their CLAUDE.md files are loaded automatically
  const extraDirs: string[] = [];
  const extraBase = '/workspace/extra';
  if (fs.existsSync(extraBase)) {
    for (const entry of fs.readdirSync(extraBase)) {
      const fullPath = path.join(extraBase, entry);
      if (fs.statSync(fullPath).isDirectory()) {
        extraDirs.push(fullPath);
      }
    }
  }
  if (extraDirs.length > 0) {
    log(`Additional directories: ${extraDirs.join(', ')}`);
  }

  for await (const message of query({
    prompt: stream,
    options: {
      cwd: '/workspace/group',
      additionalDirectories: extraDirs.length > 0 ? extraDirs : undefined,
      resume: sessionId,
      resumeSessionAt: resumeAt,
      systemPrompt: mergedMemory
        ? { type: 'preset' as const, preset: 'claude_code' as const, append: mergedMemory }
        : undefined,
      allowedTools: [
        'Bash',
        'Read', 'Write', 'Edit', 'Glob', 'Grep',
        'WebSearch', 'WebFetch',
        'Task', 'TaskOutput', 'TaskStop',
        'TeamCreate', 'TeamDelete', 'SendMessage',
        'TodoWrite', 'ToolSearch', 'Skill',
        'NotebookEdit',
        'mcp__nanoclaw__*',
        'mcp__gmail__*',
      ],
      env: sdkEnv,
      permissionMode: 'bypassPermissions',
      allowDangerouslySkipPermissions: true,
      settingSources: ['project', 'user'],
      mcpServers: {
        nanoclaw: {
          command: 'node',
          args: [mcpServerPath],
          env: {
            NANOCLAW_CHAT_JID: containerInput.chatJid,
            NANOCLAW_GROUP_FOLDER: containerInput.groupFolder,
            NANOCLAW_IS_MAIN: containerInput.isMain ? '1' : '0',
          },
        },
        gmail: {
          command: 'npx',
          args: ['-y', '@gongrzhe/server-gmail-autoauth-mcp'],
        },
      },
      hooks: {
        PreCompact: [{ hooks: [createPreCompactHook()] }],
        PreToolUse: [{ matcher: 'Bash', hooks: [createSanitizeBashHook()] }],
      },
    }
  })) {
    messageCount++;
    const msgType = message.type === 'system' ? `system/${(message as { subtype?: string }).subtype}` : message.type;
    log(`[msg #${messageCount}] type=${msgType}`);

    if (message.type === 'assistant' && 'uuid' in message) {
      lastAssistantUuid = (message as { uuid: string }).uuid;
    }

    if (message.type === 'system' && message.subtype === 'init') {
      newSessionId = message.session_id;
      log(`Session initialized: ${newSessionId}`);
    }

    if (message.type === 'system' && (message as { subtype?: string }).subtype === 'task_notification') {
      const tn = message as { task_id: string; status: string; summary: string };
      log(`Task notification: task=${tn.task_id} status=${tn.status} summary=${tn.summary}`);
    }

    if (message.type === 'result') {
      resultCount++;
      const textResult = 'result' in message ? (message as { result?: string }).result : null;
      log(`Result #${resultCount}: subtype=${message.subtype}${textResult ? ` text=${textResult.slice(0, 200)}` : ''}`);
      writeOutput({
        status: 'success',
        result: textResult || null,
        newSessionId
      });
    }
  }

  ipcPolling = false;
  log(`Query done. Messages: ${messageCount}, results: ${resultCount}, lastAssistantUuid: ${lastAssistantUuid || 'none'}, closedDuringQuery: ${closedDuringQuery}`);
  return { newSessionId, lastAssistantUuid, closedDuringQuery };
}

function getOpenRouterConfig(sdkEnv: Record<string, string | undefined>): OpenRouterConfig | null {
  const apiKey = sdkEnv.OPENROUTER_API_KEY;
  if (!apiKey) return null;

  const baseUrl = (sdkEnv.OPENROUTER_BASE_URL || 'https://openrouter.ai/api/v1').replace(/\/+$/, '');
  const model = sdkEnv.OPENROUTER_MODEL || 'x-ai/grok-4.1-fast';

  return {
    apiKey,
    model,
    baseUrl,
    httpReferer: sdkEnv.OPENROUTER_HTTP_REFERER,
    title: sdkEnv.OPENROUTER_TITLE,
  };
}

async function runOpenRouterTurn(
  messages: OpenRouterMessage[],
  config: OpenRouterConfig,
): Promise<string> {
  const headers: Record<string, string> = {
    Authorization: `Bearer ${config.apiKey}`,
    'Content-Type': 'application/json',
  };
  if (config.httpReferer) headers['HTTP-Referer'] = config.httpReferer;
  if (config.title) headers['X-Title'] = config.title;

  const response = await fetch(`${config.baseUrl}/chat/completions`, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      model: config.model,
      messages,
    }),
  });

  if (!response.ok) {
    const body = await response.text();
    throw new Error(`OpenRouter error ${response.status}: ${body.slice(0, 400)}`);
  }

  const payload = await response.json() as {
    choices?: Array<{ message?: { content?: string } }>;
  };
  const text = payload.choices?.[0]?.message?.content;
  if (!text) {
    throw new Error('OpenRouter returned no assistant content');
  }
  return text;
}

function shouldHandleGmailDirectly(prompt: string): boolean {
  const p = prompt.toLowerCase();
  const asksEmail = /\b(gmail|email|inbox)\b/.test(p);
  const asksRead = /\b(check|read|list|show|unread|latest|new)\b/.test(p);
  return asksEmail && asksRead;
}

function shouldHandleGmailSendDirectly(prompt: string): boolean {
  const p = prompt.toLowerCase();
  const asksEmail = /\b(gmail|email|mail)\b/.test(p);
  const asksSend = /\b(send|deliver)\b/.test(p);
  return asksEmail && asksSend;
}

function shouldHandleGmailSentSearchDirectly(prompt: string): boolean {
  const p = prompt.toLowerCase();
  return /\b(gmail|email|mail)\b/.test(p) && /\b(sent|draft)\b/.test(p) && /\b(check|search|find|show|look)\b/.test(p);
}

function shouldHandleCalendarListDirectly(prompt: string): boolean {
  const p = prompt.toLowerCase();
  const asksCalendar = /\b(calendar|events?)\b/.test(p);
  const asksList = /\b(show|list|upcoming|today|tomorrow|next|for)\b/.test(p) || p.includes('my calendar');
  return asksCalendar && asksList;
}

function shouldHandleCalendarCreateDirectly(prompt: string): boolean {
  const p = prompt.toLowerCase();
  const asksCalendar = /\b(calendar|event)\b/.test(p);
  const asksCreate = /\b(create|add|schedule|book)\b/.test(p);
  return asksCalendar && asksCreate;
}

function shouldHandleCalendarHealthDirectly(prompt: string): boolean {
  const p = prompt.toLowerCase();
  const asksCalendar = /\bgoogle calendar|calendar\b/.test(p);
  const asksHealth = /\b(work|working|access|connected|setup|set up|status|fix)\b/.test(p);
  return asksCalendar && asksHealth;
}

function shouldHandleCalendarListCalendarsDirectly(prompt: string): boolean {
  const p = prompt.toLowerCase();
  const asksCalendar = /\bcalendar|calendars|google calendar\b/.test(p);
  const asksListCalendars = /\bshared calendars|which calendars|what calendars|list calendars|available calendars\b/.test(p);
  return asksCalendar && asksListCalendars;
}

function parseSendEmailIntent(prompt: string): ParsedSendEmailIntent | null {
  const toMatch = prompt.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i);
  if (!toMatch) return null;
  const to = toMatch[0];

  const quotedSubject = prompt.match(/subject\s*[:=]\s*["“](.+?)["”]/i);
  const unquotedSubject = prompt.match(/subject\s*[:=]\s*([^\n.]+)/i);
  const subject = (quotedSubject?.[1] || unquotedSubject?.[1] || 'Test email from Stella').trim();

  const quotedBody = prompt.match(/body\s*[:=]\s*["“]([\s\S]+?)["”]/i);
  const unquotedBody = prompt.match(/body\s*[:=]\s*([^\n]+)/i);
  const body = (quotedBody?.[1] || unquotedBody?.[1] || 'Hi John, this is a test email from Stella.').trim();

  return { to, subject, body };
}

function parseCalendarCreateIntent(prompt: string, timezone: string): ParsedCalendarCreateIntent | null {
  const summaryQuoted = prompt.match(/(?:title|summary|event)\s*[:=]\s*["“](.+?)["”]/i);
  const summaryUnquoted = prompt.match(/(?:title|summary|event)\s*[:=]\s*([^\n]+)/i);
  const summary = (summaryQuoted?.[1] || summaryUnquoted?.[1] || 'New event').trim();

  const startMatch = prompt.match(/start\s*[:=]\s*([0-9]{4}-[0-9]{2}-[0-9]{2}[T ][0-9]{2}:[0-9]{2}(?::[0-9]{2})?(?:Z|[+-][0-9]{2}:[0-9]{2})?)/i);
  const endMatch = prompt.match(/end\s*[:=]\s*([0-9]{4}-[0-9]{2}-[0-9]{2}[T ][0-9]{2}:[0-9]{2}(?::[0-9]{2})?(?:Z|[+-][0-9]{2}:[0-9]{2})?)/i);

  if (!startMatch || !endMatch) return null;

  const normalize = (v: string): string => {
    const t = v.trim().replace(' ', 'T');
    return /(?:Z|[+-][0-9]{2}:[0-9]{2})$/.test(t) ? t : `${t}:00`;
  };

  return {
    summary,
    startIso: normalize(startMatch[1]),
    endIso: normalize(endMatch[1]),
    timezone,
  };
}

function parseCalendarWindowDays(prompt: string): number {
  const p = prompt.toLowerCase();
  if (/\btoday\b/.test(p)) return 1;
  if (/\btomorrow\b/.test(p)) return 2;
  const explicit = p.match(/\bnext\s+(\d+)\s+days?\b/);
  if (explicit) {
    const n = Number(explicit[1]);
    if (Number.isFinite(n) && n >= 1 && n <= 60) return n;
  }
  const explicitFor = p.match(/\bfor\s+(\d+)\s+days?\b/);
  if (explicitFor) {
    const n = Number(explicitFor[1]);
    if (Number.isFinite(n) && n >= 1 && n <= 60) return n;
  }
  const explicitBare = p.match(/\b(\d+)\s+days?\b/);
  if (explicitBare) {
    const n = Number(explicitBare[1]);
    if (Number.isFinite(n) && n >= 1 && n <= 60) return n;
  }
  if (/\bnext\s+week\b/.test(p)) return 7;
  if (/\bnext\b/.test(p)) return 7;
  return 3;
}

function getHeader(headers: Array<{ name: string; value: string }> | undefined, name: string): string {
  if (!headers) return '';
  return headers.find(h => h.name.toLowerCase() === name.toLowerCase())?.value || '';
}

async function refreshGmailAccessToken(creds: GmailOAuthCredentials): Promise<string> {
  const tokenUri = creds.token_uri || 'https://oauth2.googleapis.com/token';
  if (!creds.refresh_token || !creds.client_id || !creds.client_secret) {
    throw new Error('Missing refresh_token/client_id/client_secret in ~/.gmail-mcp/credentials.json');
  }

  const body = new URLSearchParams({
    grant_type: 'refresh_token',
    refresh_token: creds.refresh_token,
    client_id: creds.client_id,
    client_secret: creds.client_secret,
  });

  const response = await fetch(tokenUri, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body,
  });
  if (!response.ok) {
    throw new Error(`OAuth refresh failed (${response.status}): ${(await response.text()).slice(0, 300)}`);
  }
  const data = await response.json() as { access_token?: string };
  if (!data.access_token) throw new Error('OAuth refresh did not return access_token');
  return data.access_token;
}

async function runDirectGmailUnread(limit = 5): Promise<string> {
  const credsPath = '/home/node/.gmail-mcp/credentials.json';
  if (!fs.existsSync(credsPath)) {
    throw new Error('Gmail credentials not found at ~/.gmail-mcp/credentials.json');
  }
  const creds = JSON.parse(fs.readFileSync(credsPath, 'utf-8')) as GmailOAuthCredentials;
  const accessToken = await refreshGmailAccessToken(creds);

  const listResp = await fetch(
    `https://gmail.googleapis.com/gmail/v1/users/me/messages?q=is:unread&maxResults=${limit}`,
    { headers: { Authorization: `Bearer ${accessToken}` } },
  );
  if (!listResp.ok) {
    throw new Error(`Gmail list failed (${listResp.status}): ${(await listResp.text()).slice(0, 300)}`);
  }
  const listData = await listResp.json() as { messages?: Array<{ id: string }> };
  const messages = listData.messages || [];
  if (messages.length === 0) {
    return 'No unread Gmail messages.';
  }

  const lines: string[] = [`Unread Gmail messages (${messages.length}):`];
  for (const msg of messages) {
    const metaResp = await fetch(
      `https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}?format=metadata&metadataHeaders=From&metadataHeaders=Subject&metadataHeaders=Date`,
      { headers: { Authorization: `Bearer ${accessToken}` } },
    );
    if (!metaResp.ok) {
      lines.push(`- ${msg.id}: [metadata fetch failed ${metaResp.status}]`);
      continue;
    }
    const meta = await metaResp.json() as { payload?: { headers?: Array<{ name: string; value: string }> } };
    const headers = meta.payload?.headers;
    const from = getHeader(headers, 'From') || '(unknown sender)';
    const subject = getHeader(headers, 'Subject') || '(no subject)';
    const date = getHeader(headers, 'Date') || '(no date)';
    lines.push(`- ${msg.id} | From: ${from} | Subject: ${subject} | Date: ${date}`);
  }
  return lines.join('\n');
}

function toBase64Url(input: string): string {
  return Buffer.from(input, 'utf-8')
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/g, '');
}

async function runDirectGmailSend(to: string, subject: string, body: string): Promise<string> {
  const credsPath = '/home/node/.gmail-mcp/credentials.json';
  if (!fs.existsSync(credsPath)) {
    throw new Error('Gmail credentials not found at ~/.gmail-mcp/credentials.json');
  }
  const creds = JSON.parse(fs.readFileSync(credsPath, 'utf-8')) as GmailOAuthCredentials;
  const accessToken = await refreshGmailAccessToken(creds);

  const mime = [
    `To: ${to}`,
    `Subject: ${subject}`,
    'Content-Type: text/plain; charset="UTF-8"',
    '',
    body,
  ].join('\r\n');

  const response = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/messages/send', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ raw: toBase64Url(mime) }),
  });
  if (!response.ok) {
    throw new Error(`Gmail send failed (${response.status}): ${(await response.text()).slice(0, 300)}`);
  }
  const data = await response.json() as { id?: string };
  return `Email sent successfully.\n- To: ${to}\n- Subject: ${subject}\n- Gmail Message ID: ${data.id || 'unknown'}`;
}

async function runDirectGmailSentSearch(recipient: string, limit = 5): Promise<string> {
  const credsPath = '/home/node/.gmail-mcp/credentials.json';
  if (!fs.existsSync(credsPath)) {
    throw new Error('Gmail credentials not found at ~/.gmail-mcp/credentials.json');
  }
  const creds = JSON.parse(fs.readFileSync(credsPath, 'utf-8')) as GmailOAuthCredentials;
  const accessToken = await refreshGmailAccessToken(creds);

  const q = encodeURIComponent(`in:sent to:${recipient}`);
  const listResp = await fetch(
    `https://gmail.googleapis.com/gmail/v1/users/me/messages?q=${q}&maxResults=${limit}`,
    { headers: { Authorization: `Bearer ${accessToken}` } },
  );
  if (!listResp.ok) {
    throw new Error(`Gmail sent-search failed (${listResp.status}): ${(await listResp.text()).slice(0, 300)}`);
  }
  const listData = await listResp.json() as { messages?: Array<{ id: string }> };
  const messages = listData.messages || [];
  if (messages.length === 0) {
    return `No sent messages found for ${recipient}.`;
  }

  const lines: string[] = [`Sent messages to ${recipient} (${messages.length}):`];
  for (const msg of messages) {
    const metaResp = await fetch(
      `https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}?format=metadata&metadataHeaders=To&metadataHeaders=Subject&metadataHeaders=Date`,
      { headers: { Authorization: `Bearer ${accessToken}` } },
    );
    if (!metaResp.ok) {
      lines.push(`- ${msg.id}: [metadata fetch failed ${metaResp.status}]`);
      continue;
    }
    const meta = await metaResp.json() as { payload?: { headers?: Array<{ name: string; value: string }> } };
    const headers = meta.payload?.headers;
    const to = getHeader(headers, 'To') || '(unknown recipient)';
    const subject = getHeader(headers, 'Subject') || '(no subject)';
    const date = getHeader(headers, 'Date') || '(no date)';
    lines.push(`- ${msg.id} | To: ${to} | Subject: ${subject} | Date: ${date}`);
  }
  return lines.join('\n');
}

async function runDirectCalendarList(windowDays: number, perCalendarLimit = 50): Promise<string> {
  const credsPath = '/home/node/.gcalendar-mcp/credentials.json';
  if (!fs.existsSync(credsPath)) {
    throw new Error('Google Calendar credentials not found at ~/.gcalendar-mcp/credentials.json');
  }
  const creds = JSON.parse(fs.readFileSync(credsPath, 'utf-8')) as GmailOAuthCredentials;
  const accessToken = await refreshGmailAccessToken(creds);

  const timeMin = new Date().toISOString();
  const timeMax = new Date(Date.now() + windowDays * 24 * 60 * 60 * 1000).toISOString();

  const calendarListResp = await fetch('https://www.googleapis.com/calendar/v3/users/me/calendarList', {
    headers: { Authorization: `Bearer ${accessToken}` },
  });
  if (!calendarListResp.ok) {
    throw new Error(`Calendar list failed (${calendarListResp.status}): ${(await calendarListResp.text()).slice(0, 300)}`);
  }
  const calendarsData = await calendarListResp.json() as {
    items?: Array<{ id?: string }>;
  };
  const calendarIds = (calendarsData.items || []).map(c => c.id).filter((v): v is string => Boolean(v));

  type EventRow = { sortStart: number; date: string; start: string; end: string; title: string };
  const dedup = new Map<string, EventRow>();
  const dateFmt = new Intl.DateTimeFormat('en-CA', { timeZone: process.env.TZ || 'Europe/Rome', year: 'numeric', month: '2-digit', day: '2-digit' });
  const timeFmt = new Intl.DateTimeFormat('en-GB', { timeZone: process.env.TZ || 'Europe/Rome', hour: '2-digit', minute: '2-digit', hour12: false });

  for (const calId of calendarIds) {
    const url = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calId)}/events?timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime&maxResults=${perCalendarLimit}`;
    const resp = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
    if (!resp.ok) continue;
    const data = await resp.json() as {
      items?: Array<{ summary?: string; start?: { dateTime?: string; date?: string }; end?: { dateTime?: string; date?: string } }>;
    };

    for (const ev of data.items || []) {
      const summary = ev.summary || '(no title)';
      const startRaw = ev.start?.dateTime || ev.start?.date;
      const endRaw = ev.end?.dateTime || ev.end?.date;
      if (!startRaw || !endRaw) continue;

      let date = '';
      let start = '';
      let end = '';
      let sortStart = 0;

      if (ev.start?.dateTime && ev.end?.dateTime) {
        const s = new Date(ev.start.dateTime);
        const e = new Date(ev.end.dateTime);
        date = dateFmt.format(s);
        start = timeFmt.format(s);
        end = timeFmt.format(e);
        sortStart = s.getTime();
      } else {
        // All-day event
        const s = new Date(`${ev.start?.date}T00:00:00`);
        date = dateFmt.format(s);
        start = 'All day';
        end = 'All day';
        sortStart = s.getTime();
      }

      const key = `${date}|${start}|${end}|${summary}`.toLowerCase();
      dedup.set(key, { sortStart, date, start, end, title: summary });
    }
  }

  const rows = [...dedup.values()].sort((a, b) => a.sortStart - b.sortStart);
  if (rows.length === 0) {
    return `No calendar events found in the next ${windowDays} day(s).`;
  }

  const lines: string[] = rows.map(r => `${r.date}, ${r.start} - ${r.end}, ${r.title}`);
  return lines.join('\n');
}

async function runDirectCalendarCreate(intent: ParsedCalendarCreateIntent): Promise<string> {
  const credsPath = '/home/node/.gcalendar-mcp/credentials.json';
  if (!fs.existsSync(credsPath)) {
    throw new Error('Google Calendar credentials not found at ~/.gcalendar-mcp/credentials.json');
  }
  const creds = JSON.parse(fs.readFileSync(credsPath, 'utf-8')) as GmailOAuthCredentials;
  const accessToken = await refreshGmailAccessToken(creds);

  const payload = {
    summary: intent.summary,
    start: { dateTime: intent.startIso, timeZone: intent.timezone },
    end: { dateTime: intent.endIso, timeZone: intent.timezone },
  };
  const response = await fetch('https://www.googleapis.com/calendar/v3/calendars/primary/events', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(payload),
  });
  if (!response.ok) {
    throw new Error(`Calendar create failed (${response.status}): ${(await response.text()).slice(0, 300)}`);
  }
  const data = await response.json() as { id?: string; htmlLink?: string };
  return [
    'Calendar event created successfully.',
    `- ID: ${data.id || 'unknown'}`,
    `- Title: ${intent.summary}`,
    `- Start: ${intent.startIso}`,
    `- End: ${intent.endIso}`,
    data.htmlLink ? `- Link: ${data.htmlLink}` : '',
  ].filter(Boolean).join('\n');
}

async function runDirectCalendarHealthCheck(): Promise<string> {
  const credsPath = '/home/node/.gcalendar-mcp/credentials.json';
  if (!fs.existsSync(credsPath)) {
    throw new Error('Google Calendar credentials not found at ~/.gcalendar-mcp/credentials.json');
  }
  const creds = JSON.parse(fs.readFileSync(credsPath, 'utf-8')) as GmailOAuthCredentials;
  const accessToken = await refreshGmailAccessToken(creds);

  const response = await fetch('https://www.googleapis.com/calendar/v3/users/me/calendarList', {
    headers: { Authorization: `Bearer ${accessToken}` },
  });
  if (!response.ok) {
    throw new Error(`Calendar health-check failed (${response.status}): ${(await response.text()).slice(0, 300)}`);
  }
  const data = await response.json() as { items?: Array<{ id?: string; summary?: string }> };
  const items = data.items || [];
  const lines = [
    'Google Calendar is connected and working.',
    `Accessible calendars: ${items.length}`,
    ...items.slice(0, 5).map(c => `- ${c.id || 'unknown'} | ${c.summary || '(no title)'}`),
  ];
  return lines.join('\n');
}

async function main(): Promise<void> {
  let containerInput: ContainerInput;

  try {
    const stdinData = await readStdin();
    containerInput = JSON.parse(stdinData);
    // Delete the temp file the entrypoint wrote — it contains secrets
    try { fs.unlinkSync('/tmp/input.json'); } catch { /* may not exist */ }
    log(`Received input for group: ${containerInput.groupFolder}`);
  } catch (err) {
    writeOutput({
      status: 'error',
      result: null,
      error: `Failed to parse input: ${err instanceof Error ? err.message : String(err)}`
    });
    process.exit(1);
  }

  // Build SDK env: merge secrets into process.env for the SDK only.
  // Secrets never touch process.env itself, so Bash subprocesses can't see them.
  const sdkEnv: Record<string, string | undefined> = { ...process.env };
  for (const [key, value] of Object.entries(containerInput.secrets || {})) {
    sdkEnv[key] = value;
  }

  const __dirname = path.dirname(fileURLToPath(import.meta.url));
  const mcpServerPath = path.join(__dirname, 'ipc-mcp-stdio.js');

  let sessionId = containerInput.sessionId;
  if (!sessionId) {
    sessionId = `session-${Date.now()}`;
  }
  fs.mkdirSync(IPC_INPUT_DIR, { recursive: true });

  // Clean up stale _close sentinel from previous container runs
  try { fs.unlinkSync(IPC_INPUT_CLOSE_SENTINEL); } catch { /* ignore */ }

  // Build initial prompt (drain any pending IPC messages too)
  let prompt = containerInput.prompt;
  if (containerInput.isScheduledTask) {
    prompt = `[SCHEDULED TASK - The following message was sent automatically and is not coming directly from the user or group.]\n\n${prompt}`;
  }
  const pending = drainIpcInput();
  if (pending.length > 0) {
    log(`Draining ${pending.length} pending IPC messages into initial prompt`);
    prompt += '\n' + pending.join('\n');
  }

  const openRouterConfig = getOpenRouterConfig(sdkEnv);
  if (openRouterConfig) {
    log(`Using OpenRouter provider with model: ${openRouterConfig.model}`);

    const messages: OpenRouterMessage[] = [];
    const memoryParts: string[] = [];
    const groupMemory = readMemoryMarkdown('/workspace/group');
    if (groupMemory?.trim()) memoryParts.push(groupMemory);
    if (!containerInput.isMain) {
      const globalMemory = readMemoryMarkdown('/workspace/global');
      if (globalMemory?.trim()) memoryParts.push(globalMemory);
    }
    if (memoryParts.length > 0) {
      messages.push({ role: 'system', content: memoryParts.join('\n\n') });
    }

    try {
      while (true) {
        let result: string;
        if (shouldHandleCalendarListCalendarsDirectly(prompt)) {
          result = await runDirectCalendarHealthCheck();
        } else if (shouldHandleCalendarHealthDirectly(prompt)) {
          result = await runDirectCalendarHealthCheck();
        } else if (shouldHandleCalendarCreateDirectly(prompt)) {
          const tz = process.env.TZ || 'Europe/Rome';
          const intent = parseCalendarCreateIntent(prompt, tz);
          if (!intent) {
            result = [
              'I need explicit start/end timestamps to create the event.',
              'Example: create calendar event title: "Parent Meeting" start: 2026-02-23T09:00 end: 2026-02-23T10:00',
            ].join('\n');
          } else {
            result = await runDirectCalendarCreate(intent);
          }
        } else if (shouldHandleCalendarListDirectly(prompt)) {
          const windowDays = parseCalendarWindowDays(prompt);
          result = await runDirectCalendarList(windowDays, 25);
        } else if (shouldHandleGmailSendDirectly(prompt)) {
          const intent = parseSendEmailIntent(prompt);
          if (!intent) {
            result = 'I need a recipient email address to send. Example: send a test email to name@example.com';
          } else {
            result = await runDirectGmailSend(intent.to, intent.subject, intent.body);
          }
        } else if (shouldHandleGmailSentSearchDirectly(prompt)) {
          const recipient = prompt.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i)?.[0];
          if (!recipient) {
            result = 'I need a recipient email address to search sent mail. Example: check sent mail to name@example.com';
          } else {
            result = await runDirectGmailSentSearch(recipient, 5);
          }
        } else if (shouldHandleGmailDirectly(prompt)) {
          result = await runDirectGmailUnread(5);
        } else {
          messages.push({ role: 'user', content: prompt });
          result = await runOpenRouterTurn(messages, openRouterConfig);
          messages.push({ role: 'assistant', content: result });
        }

        writeOutput({
          status: 'success',
          result,
          newSessionId: sessionId,
        });

        writeOutput({ status: 'success', result: null, newSessionId: sessionId });

        const nextMessage = await waitForIpcMessage();
        if (nextMessage === null) {
          log('Close sentinel received, exiting OpenRouter loop');
          break;
        }
        prompt = nextMessage;
      }
      return;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      log(`OpenRouter error: ${errorMessage}`);
      writeOutput({
        status: 'error',
        result: null,
        newSessionId: sessionId,
        error: errorMessage,
      });
      process.exit(1);
    }
  }

  // Query loop: run query → wait for IPC message → run new query → repeat
  let resumeAt: string | undefined;
  try {
    while (true) {
      log(`Starting query (session: ${sessionId || 'new'}, resumeAt: ${resumeAt || 'latest'})...`);

      const queryResult = await runQuery(prompt, sessionId, mcpServerPath, containerInput, sdkEnv, resumeAt);
      if (queryResult.newSessionId) {
        sessionId = queryResult.newSessionId;
      }
      if (queryResult.lastAssistantUuid) {
        resumeAt = queryResult.lastAssistantUuid;
      }

      // If _close was consumed during the query, exit immediately.
      // Don't emit a session-update marker (it would reset the host's
      // idle timer and cause a 30-min delay before the next _close).
      if (queryResult.closedDuringQuery) {
        log('Close sentinel consumed during query, exiting');
        break;
      }

      // Emit session update so host can track it
      writeOutput({ status: 'success', result: null, newSessionId: sessionId });

      log('Query ended, waiting for next IPC message...');

      // Wait for the next message or _close sentinel
      const nextMessage = await waitForIpcMessage();
      if (nextMessage === null) {
        log('Close sentinel received, exiting');
        break;
      }

      log(`Got new message (${nextMessage.length} chars), starting new query`);
      prompt = nextMessage;
    }
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : String(err);
    log(`Agent error: ${errorMessage}`);
    writeOutput({
      status: 'error',
      result: null,
      newSessionId: sessionId,
      error: errorMessage
    });
    process.exit(1);
  }
}

main();
